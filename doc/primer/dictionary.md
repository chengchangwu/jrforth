# 字典

Forth 系統核心的資料結構有二：

* 堆疊：參數堆疊、浮點堆疊，以及本書未深入提及的返回堆疊。指令和指令之間的資料透過堆疊傳遞。
* 字典：記錄 Forth 所有的指令。提供文本解譯器查尋及執行指令的功能。

在之前的章節，我們花了許多篇幅熟悉堆疊的操作。以及熟悉眾多指令中的一種：冒號定義指令。在這章我們把重點放在字典，以及指令存放在字典中的方式。我們將熟悉除了冒號定義之外其他型式的指令：字典標記指令、常數指令、變數指令、自行定義的資料結構指令。我們也將學習如何使用字典中的記憶空間。

## 指令 words

Forth 能執行 `+` 、 `-` 、`*` 、 `/` 這些指令，是因為它內建的字典 (dictionary) 提供了搜尋及執行指令的功能。如果我們想知道字典中有多少指令，我們可以執行指令 `words`。

```
rf> words

-work (abort) quit evaluate >in source tib #tib fill c, min
max +! 2variable 2! 2@ align aligned spaces space bl cr
?dup f> >= <= h. hex decimal accept 1/sec hz rpm um/msec
mm/min usec msec sec minute hr rad deg um mm meter fnegate
fceil fround floor fmax fmin f< f0= f0< f~ f** f/ f* f- f+
...
```

字典記載了指令的名稱、行為、資料，並提供搜尋指令的方法。

```
指令
            +------+
        名稱 |  +   |
            +------+      +-----------------+
        行為 | plus | ---> | 將堆疊上的數字相加 | 程式碼空間
            +------+      +-----------------+
        資料 | 無   |
            +------+

字典
            +--------+      +---------+      +------+      +----------+
  LAST ---> | -work  | ---> | (abort) | ---> | quit | ---> | evaluate | --->
            +--------+      +---------+      +------+      +----------+
            | unmark |      | nest    |      | nest |      | nest     |
            +--------+      +---------+      +------+      +----------+
            |        |      |         |      |      |      |          |
            +--------+      +---------+      +------+      +----------+
```

指令 `words` 先顯示較晚定義的指令，再顯示較早定義的指令。以之前的例子來看，指令 `-work` 是最後一個定義的指令，再來是 `(abort)`，再來是 `quit`。示義圖中，LAST 指的是最後一個定義的指令，也就是 `-work`。它是一個之後會提到的字典標記指令，執行它時，它的行為是 `unmark`。其他的幾個指令的行為是 `nest`。行為是 `nest` 的指令就是我們之前提到的冒號定義指令。

現在讓我們定義本書的第一個指令 `hello`。看看字典有什麼變化。

```
rf> : hello ." Hello World!" ;
 ok
rf> words

hello -work (abort) quit evaluate >in source tib #tib fill
c, min max +! 2variable 2! 2@ align aligned spaces space bl
...
```

可以看到 `words` 顯示的最後一個指令是剛才定義的 `hello`。

```
: hello   ." Hello World!" ;

            +-------+                                  +-------+
LAST -> 名稱 | hello | -------------------------------> | -work | ---> 
            +-------+        +---------------+         +-------+
        行為 | nest  | -----> | 執行冒號定義指令 | 程式碼空間
            +-------+        +---------------+
        資料 |       | --+
            +-------+   |    +-----+----+--------------+------+------+
                        +--> | _s" | 12 | Hello World! | type | exit | 資料空間
                             +-----+----+--------------+------+------+
```

從圖中可以看出指令的行為被放在程式碼空間 (code space) 中，資料則放在資料空間 (data space) 中。
這兒所謂的空間，就是一塊連續的記憶體。程式碼空間放的是可以執行的機器語言程式碼。資料空間中放的則是機器語言程式碼執行時所需的資料。某些系統裡將機器語言程式碼和資料放在同一個空間裡。在另外一些系統中，存放名稱、行為、資料的那個資料結構被放在另一個名為標頭空間 (header space) 的記憶體中。

上圖中的 `nest` 對應的是執行冒號定義指令的機器語言程式碼。它會取得資料空間中的 Forth 指令依順序執行。第一個指令 `_s"` 會將長度為 12 的字串 "Hello World!" 的開始位置和長度放在堆疊上。其後的 `type` 則會依據堆疊上的位置和長度印出字串的內容。這兒的 `_s"` 和其後的數字和字串，以及 `type` ，都是编譯指令 `."` 编譯進字典中的。例中顯示的只是 rtForth 的編譯結果。不同的 Forth 系統有不同的编譯方式。指令 `_s"` 不是 Forth 2012 的標準指令。但是 `type` 是一個標準指令。

另有一個編譯指令 `s"` 類似 `.s"` 但只編譯上例中的 `_s"` 及其後字串的部份，不編譯 `type`。因此以下兩個冒號定義指令的效果是一樣的：

```
: hello-1   ." Hello World!" ;
: hello-2   s" Hello World!" type ;
```

### 本節指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `words` | ( -- ) &emsp; 顯示字典中目前能使用的指令 | words |
| `s" <string>"` | ( -- ) &emsp;  編譯其後的字串直到下一個 "。 | s-quote |
| `type` | ( addr n -- ) &emsp; 印出資料空間位置 addr 處，長度為 n 的字串 | type |

-------------------
## 標記指令 (Marker)

當你使用 rtForth，不想保留自己定義的指令時，可以執行 `-work。
```
rf> -work
 ok
rf> words

(abort) quit evaluate >in source tib #tib fill c, min max
+! 2variable 2! 2@ align aligned ...
```
你會發現，不只是剛剛定義的 `hello` 不見了，連 `-work` 也不見。

指令 `-work` 標記了字典的特定位置 (包括定義 -work 時資料空間和程式碼空間的位置)。執行時，會丟棄指令本身以及其後的所有指令，並且歸還這些指令使用的資料空間和程式碼空間。

你可以使用 `marker` 定義這類標記指令。

```
rf> marker -work
 ok
rf> words

-work (abort) quit evaluate >in source tib #tib fill c, min
max +! 2variable 2! 2@ align aligned ...
```

於是一個新的 `-work 又出現了。

指令 `-work` 並不是 Forth 2012 的標準指令。但是 `marker` 是一個標準指令。它的主要用處是標記字典的特定位置，以便在必要時移除一群指令。舉個例子，有一台工具機，加工不同的工件時，要選擇不同的工件程式。機器會依工件程式執行。執行工件程式的指令都叫做 `run`，但是不同工件程式的 `run` 內容不同。這時就可以如下使用 `marker` ：

首先在原有的字典最後增加一個標記指令 `-program`，在載入新的以 Forth 實現的工件程式之前都先執行 `-program   marker -program`。最後才定義 `run`。 於是，之前的工件程式被丟棄，新的 `-program` 以及新的 `run` 被定義。

```
\ 不隨著工件程式變動的指令
: xxx .... ;
marker -program
```

某個工件程式
```
-program   marker -program

\ 定義新的工件程式
: run ... ;

\ 執行工件程式
run
```
-----------
## 常數
像 `true` 、 `false` 和 `pi` 這類被賦與固定數值的指令，被稱為常數。Forth 定義整數常數的方法如下：
```
<整數> constant <常數名>
<整數> <整數> 2constant <常數名>
<浮點數> fconstant <常數名>
```
指令 `constant` 從堆疊上取得整數，從輸入緩衝區取得跟在它後面的名稱，然後在字典裡建立了一個同名的常數。指令 `fconstant` 的行為類似，但定義的是浮點數常數。而 2constant 則從堆疊上取得一組兩個整數，為它們定義了一個常數。

例子：定義自己的真、假、圓週率常數
```
rf> -1 constant my-true
 ok
rf> 0 constant my-false
 ok
rf> 3.141592653e fconstant my-pi
 ok
rf> my-true .  my-false .  my-pi f.
-1 0 3.1415927  ok
```

例子：某機器只能在 4 度到 40 度之間工作，超過就要停機，請將 4 和 40 這組數字定為一常數 `range` 並以 `within` 分別判斷 3 度、20 度及 40 度是否落在機器可以工作的範圍內。

```
4 40 2constant range
: in-range ( n -- )   range within ;
```

下圖顯示使用 `constant` 、 `2constant` 和 `fconstant` 定義出來的字在字典中的樣子。這只是一個示意圖。不同的 Forth 版本間差異可能很大。

```
-1 constant my-true

            +---------+
        名稱 | my-true |
            +---------+       +---------------------------+
        行為 | const   | ----> | 將資料空間內的整數放上資料堆疊 | 程式碼空間
            +---------+       +---------------------------+
        資料 |         | --+
            +---------+   |   +----+
                          +-> | -1 | 資料空間
                              +----+

3.141592653e fconstant my-pi

            +--------------+
        名稱 | my-pi        |
            +--------------+      +-----------------------------+
        行為 | fconst       | ---> | 將資料空間內的浮點數放上浮點堆疊 | 程式碼空間
            +--------------+      +-----------------------------+
        資料 |              | --+
            +--------------+   |   +--------------+
                               +-> | 3.141592653e | 資料空間
                                   +--------------+
4 40 2constant range

            +-----------+
        名稱 | range     |
            +-----------+      +---------------------------+
        行為 | two-const | ---> | 將資料空間內的整數放上資料堆疊 | 程式碼空間
            +-----------+      +---------------------------+
        資料 |           | --+
            +-----------+   |   +----+----+
                            +-> | 4  | 40 | 資料空間
                                +----+----+
```

### 本節指令集
| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `constant` | ( -- ) &emsp; | constant |
| `2constant` | ( -- ) &emsp; | two-constant |
| `fconstant` | ( -- ) &emsp; | f-constant |

## 變數

通常 Forth 的程式在計算過程中會將計算結果放在堆疊上，然後很快的再以其他指令處理這些結果。有些時候我們並不想立刻使用這些結果，而希望能將結果放在堆疊以外的地方。變數提供了這樣的機制：一塊能存放資料的記憶體空間。類似常數，Forth 提供了 `variable` 、 `2variable` 及 `fvariable` 讓我們能定義不同種類的變數。

例子：
```
variable 狀態  (　定義一個名為「狀態」的整數變數 )
%001 constant 冷氣  ( 以右邊數來第一個位元代表冷氣開關 )
%010 constant 風扇  ( 以右邊數來第二個位元代表風扇開關 )
%100 constant 冰箱 ( 以右邊數來第三 個位元代表風扇開關 )
%111 constant 全部
%11　狀態　!        ( 目前的狀態是冷氣和風扇都開著、冰箱關著 )
冷氣 風扇 or　狀態　!        ( 目前的狀態是冷氣和風扇都開著、冰箱關著 )
冷氣  狀態　@  and  .  ( 檢查冷氣是否開著 )
風扇  狀態　@  and  .  ( 檢查風扇是否開著 )
冰箱  狀態　@  and  .  ( 檢查冰箱是否開著 )
冷氣 冰箱 or  狀態　@ and  .  ( 檢查冷氣或是冰箱中是否至少有一個開著 )
全部  狀態 @  =  ( 是否全部開著 )
```
### 本節指令集
| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `variable` | ( -- ) &emsp; | variable |
| `2variable` | ( -- ) &emsp; | two-variable |
| `fvariable` | ( -- ) &emsp; | f-variable |
| `@` | ( -- ) &emsp; | fetch |
| `!` | ( n a -- ) &emsp; 將 n 存在位址 a  | store |
| `2@` | ( -- ) &emsp; | two-fetch |
| `2!` | ( -- ) &emsp; | two-store |
| `+!` | ( n a -- ) &emsp; 將位址 a 內的整數加 n | plus-store |
| `f@` | ( -- ) &emsp; | f-fetch |
| `f!` | ( -- ) &emsp; | f-store |

-------------------
## 定義自己的資料結構

CREATE

Forth 提供我們指令存取資料空間，但我們必須先瞭解資料空間的特性。以下是資料空間的示意圖。

```
資料空間

    較低的記憶位址                                                 here           較高的記憶位址
    +---------------+---------------+-------------+-------------+-------------------------+
    |       -1      |       0       | 3.141592653e|  4   |  40  |                         |
    +---------------+---------------+-------------+-------------+-------------------------+
      my-true 的資料   my-false 的資料  my-pi 的資料   range 的資料   未使用的空間
      4 bytes         4 bytes         8 bytes       4 + 4 bytes
      1 cell          1 cell          2 cells       1 + 1 cells
```

資料依從低到高的次序放進資料空間中。記憶體位址的單位是位元組 (byte) 。但是大多數的資料大小超過一個位元組。比如上圖中的整數是 32 位元的，浮點則是 64 位元的。Forth 系統習慣將整數所佔的位元組數目稱為一個單元 (cell)。

| rtForth | 作業系統 | 資料堆疊上整數所佔位元組數 | 資料空間中整數所佔位元組數 | 浮點數所佔位元組數 | cell 的位元組數 |
|---------|---------|-----------------------|------------------------|-----------------|---------------|
| v0.3.0  | 64 位元 Linux | 8  | 4 | 8 | 4 |
| v0.3.0  | 32 位元 Linux | 4  | 4 | 8 | 4 |

Forth 指令 `cells` 可以得到 cell 所需的位元組數。
```
rf> 1 cells .
4  ok
```

此外，資料放進記憶體的開始位址必須符合 CPU 的對齊 (alignment) 規則。

| rtForth | 作業系統 | 整數對齊位址 | 浮點數對齊位址 |
|---------|---------|------------|-------------|
| v0.3.0  | 64 位元 Linux | 4 的倍數 | 8 的倍數 |
| v0.3.0  | 32 位元 Linux | 4 的倍數 | 8 的倍數 |

Forth 指令 `here` 可以得到目前資料空間未使用部份的開始位址。指令 `allot` 則可以移動這個位址。也就是使得指定位元組數的未使用記憶體變為已配置被使用的記憶體。

```
rf> here .
1096  ok
rf> 1 allot  here .
1097  ok
```
在這個例子中，原本未使用的記憶體從 1096 開始，但以 `1 allot` 配置了一個位元組後，改從 1097 開始。本來 1096 同時符合整數和浮點數的對齊原則。現在不合了，我們可以使用指令 `align` 或 `falign` 修正 here ，重新對齊。

```
rf> align  here .
1100  ok
rf> falign  here .
1104  ok
```

### 本節指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|------------------------------------|--------|
| `cells` | ( -- ) &emsp; | cells |
| `cell+` | ( -- ) &emsp; | cell+ |
| `align` | ( -- ) &emsp; | align |
| `aligned` | ( -- ) &emsp; | aligned |
| `allot` | ( -- ) &emsp; | allot |
| `here` | ( -- ) &emsp; | here |
| `,` | ( -- ) &emsp; | comma |
| `f,` | ( -- ) &emsp; | f-comma |
| `falign` | ( -- ) &emsp; | f-align |
| `faligned` | ( -- ) &emsp; | f-aligned |
| `create` | ( -- ) &emsp; | create |

### 本節指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `marker` | ( -- ) &emsp;  | marker |

-------------
## 本章重點整理

* 字典 (dictionary)
* 變數 (variable)
* 常數 (constant)
* 單元 (cell)
* 資料空間 (data space)
* 程式碼空間 (code space)

-----------
## 本章指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|------------------------------------|--------|
| `create` | ( -- ) &emsp; | create |
| `+field` | ( -- ) &emsp; | pluse-field |