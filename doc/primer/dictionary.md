# 字典

Forth 系統核心的資料結構有二：

* 堆疊：參數堆疊、浮點堆疊，以及本書未深入提及的返回堆疊。指令和指令之間的資料透過堆疊傳遞。
* 字典：記錄 Forth 所有的指令。提供文本解譯器查尋及執行指令的功能。

在之前的章節，我們花了許多篇幅熟悉堆疊的操作。以及熟悉眾多指令中的一種：冒號定義指令。在這章我們把重點放在字典，在字典中增加新的指令的方法，以及指令存放在字典中的方式。

想在字典中增加新的指令，可以使用「定義指令」。冒號就是一種定義指令。以下是我們將在這章學到的定義指令：

* 定義字典標記： `marker`
* 定義常數：`constant` 、 `2constant` 、 `fconstant`
* 定義變數：`variable` 、 `2variable` 、 `fvariable`
* 定義資料結構：`create` 、 `+field`

我們也將學習如何使用字典中的資料空間。

## 指令 words

Forth 能執行 `+` 、 `-` 、`*` 、 `/` 這些指令，是因為它內建的字典 (dictionary) 提供了搜尋及執行指令的功能。如果我們想知道字典中有多少指令，我們可以執行指令 `words`。

```
rf> words

-work (abort) quit evaluate >in source tib #tib fill c, min
max +! 2variable 2! 2@ align aligned spaces space bl cr
?dup f> >= <= h. hex decimal accept 1/sec hz rpm um/msec
mm/min usec msec sec minute hr rad deg um mm meter fnegate
fceil fround floor fmax fmin f< f0= f0< f~ f** f/ f* f- f+
...
```

字典記載了指令的名稱、行為、資料，並提供搜尋指令的方法。

```
指令
            +------+
        名稱 |  +   |
            +------+      +-----------------+
        行為 | plus | ---> | 將堆疊上的數字相加 | 程式碼空間
            +------+      +-----------------+
        資料 | 無   |
            +------+

字典
            +--------+      +---------+      +------+      +----------+
  LAST ---> | -work  | ---> | (abort) | ---> | quit | ---> | evaluate | --->
            +--------+      +---------+      +------+      +----------+
            | unmark |      | nest    |      | nest |      | nest     |
            +--------+      +---------+      +------+      +----------+
            |        |      |         |      |      |      |          |
            +--------+      +---------+      +------+      +----------+
```

指令 `words` 先顯示較晚定義的指令，再顯示較早定義的指令。以之前的例子來看，指令 `-work` 是最後一個定義的指令，再來是 `(abort)`，再來是 `quit`。示義圖中，LAST 指的是最後一個定義的指令，也就是 `-work`。它是一個之後會提到的字典標記指令，執行它時，它的行為是 `unmark`。其他的幾個指令的行為是 `nest`。行為是 `nest` 的指令就是我們之前提到的冒號定義指令。

現在讓我們定義本書的第一個指令 `hello`。看看字典有什麼變化。

```
rf> : hello ." Hello World!" ;
 ok
rf> words

hello -work (abort) quit evaluate >in source tib #tib fill
c, min max +! 2variable 2! 2@ align aligned spaces space bl
...
```

可以看到 `words` 顯示的最後一個指令是剛才定義的 `hello`。

```
: hello   ." Hello World!" ;

            +-------+                                  +-------+
LAST -> 名稱 | hello | -------------------------------> | -work | ---> 
            +-------+        +---------------+         +-------+
        行為 | nest  | -----> | 執行冒號定義指令 | 程式碼空間
            +-------+        +---------------+
        資料 |       | --+
            +-------+   |    +-----+----+--------------+------+------+
                        +--> | _s" | 12 | Hello World! | type | exit | 資料空間
                             +-----+----+--------------+------+------+
```

從圖中可以看出指令的行為被放在程式碼空間 (code space) 中，資料則放在資料空間 (data space) 中。
這兒所謂的空間，就是一塊連續的記憶體。程式碼空間放的是可以執行的機器語言程式碼。資料空間中放的則是機器語言程式碼執行時所需的資料。某些系統裡將機器語言程式碼和資料放在同一個空間裡。在另外一些系統中，存放名稱、行為、資料的那個資料結構被放在另一個名為標頭空間 (header space) 的記憶體中。

上圖中的 `nest` 對應的是執行冒號定義指令的機器語言程式碼。它會取得資料空間中的 Forth 指令依順序執行。第一個指令 `_s"` 會將長度為 12 的字串 "Hello World!" 的開始位置和長度放在堆疊上。其後的 `type` 則會依據堆疊上的位置和長度印出字串的內容。這兒的 `_s"` 和其後的數字和字串，以及 `type` ，都是编譯指令 `."` 编譯進字典中的。例中顯示的只是 rtForth 的編譯結果。不同的 Forth 系統有不同的编譯方式。指令 `_s"` 不是 Forth 2012 的標準指令。但是 `type` 是一個標準指令。

另有一個編譯指令 `s"` 類似 `.s"` 但只編譯上例中的 `_s"` 及其後字串的部份，不編譯 `type`。因此以下兩個冒號定義指令的效果是一樣的：

```
: hello-1   ." Hello World!" ;
: hello-2   s" Hello World!" type ;
```

### 本節指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `words` | ( -- ) &emsp; 顯示字典中目前能使用的指令 | words |
| `s" <string>"` | ( -- ) &emsp;  編譯其後的字串直到下一個 "。 | s-quote |
| `type` | ( addr n -- ) &emsp; 印出資料空間位置 addr 處，長度為 n 的字串 | type |

-------------------
## 標記指令 (Marker)

當你使用 rtForth，不想保留自己定義的指令時，可以執行 `-work。
```
rf> -work
 ok
rf> words

(abort) quit evaluate >in source tib #tib fill c, min max
+! 2variable 2! 2@ align aligned ...
```
你會發現，不只是剛剛定義的 `hello` 不見了，連 `-work` 也不見。

指令 `-work` 標記了字典的特定位置 (包括定義 -work 時資料空間和程式碼空間的位置)。執行時，會丟棄指令本身以及其後的所有指令，並且歸還這些指令使用的資料空間和程式碼空間。

你可以使用 `marker` 定義這類標記指令。

```
rf> marker -work
 ok
rf> words

-work (abort) quit evaluate >in source tib #tib fill c, min
max +! 2variable 2! 2@ align aligned ...
```

於是一個新的 `-work 又出現了。

指令 `-work` 並不是 Forth 2012 的標準指令。但是 `marker` 是一個標準指令。它的主要用處是標記字典的特定位置，以便在必要時移除一群指令。

### 例子：CNC 工具機

CNC 工具機內有兩種不同類型的程式：PLC 程式，也就是所謂的階梯圖，處理機器內各種裝置的開關，以及工件程式，也就是所謂的 G 代碼，處理馬達的運動和加工行為。這兩種不同的程式，都可以透過編譯器翻譯成 Forth 指令。例如 PLC 程式可以翻譯成一個 Forth 指令 `run-plc`。工件程式可以翻譯成 Forth 指令 `run-nc`。這兩個指令都放在字典中。

Forth 本身是一個多工的系統。因此可以使用一個 Task 執行 `run-plc`，另一個 Task 執行 `run-nc`。下一章會說明 rtForth 的多工環境。

一台機器的 PLC 程式通常是不變的，開機時就載入的。但機台製造商的維護的人員有權限修改它。而工件程式則是操作員選擇後才載入的，很可能一天要換好幾個工件程式。因此我們可以用 marker 對字典進行以下的規畫：

Forth 程式一：定義不隨工件程式和 PLC 變動的指令。在開機時載入。
```
\ 定義不隨 PLC 和工件程式變動的指令。
: xxx ... ;

\ 定義 PLC 和 工件程式的 markers。一開始 PLC 程式和工件程式都是空的。
marker -plc
marker -nc
```

Forth 程式二：PLC 程式。在開機時載入，或在維護人員修改 PLC 程式時載入。
```
\ 清除之前的 PLC 程式
-plc   marker -plc

: run-plc   ... ;

\ 定義工件程式的 markers。目前工件程式是空的。
marker -nc
```

Forth 程式三：工件程式，在操作員選擇加工程式時載入。
```
-nc   marker -nc

: run-nc   ... ;
```

如此，當維護人員要修改 PLC 程式時，指令 `-plc` 會清除 PLC 程式以及之後的工件程式。並定義新的 `-plc` 和 `-nc` 這兩個 markers。當操作員要下載新的工件程式時，指令 `-nc` 會清除舊的工件程式，並定義新的 `-nc` marker。

### 本節指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `marker <name>` | ( -- ) &emsp;  | marker |

-----------
## 常數
像 `true` 、 `false` 和 `pi` 這類被賦與固定數值的指令，被稱為常數。Forth 定義整數常數的方法如下：
```
<整數> constant <常數名>
<整數> <整數> 2constant <常數名>
<浮點數> fconstant <常數名>
```
指令 `constant` 從堆疊上取得整數，從輸入緩衝區取得跟在它後面的名稱，然後在字典裡建立了一個同名的常數。指令 `fconstant` 的行為類似，但定義的是浮點數常數。而 `2constant` 則從堆疊上取得兩個整數，為它們定義了一個常數。

例一：定義自己的真、假、圓週率常數
```
rf> -1 constant my-true
 ok
rf> 0 constant my-false
 ok
rf> 3.141592653e fconstant my-pi
 ok
rf> my-true .  my-false .  my-pi f.
-1 0 3.1415927  ok
```

例二：某機器只能大於或等於 4&deg;C ，小於 40&deg;C 時工作，超過就要停機，請將 4 和 40 這組數字定為一常數 `range` 並以 `within` 分別判斷 3 度、20 度及 40 度是否落在機器可以工作的範圍內。

```
4 40 2constant range
: in-range ( n -- )   range within ;
```

以下是使用 `constant` 和 `fconstant` 定義出來的指令在字典中的示意圖。

```
-1 constant my-true

            +---------+
        名稱 | my-true |
            +---------+       +---------------------------+
        行為 | const   | ----> | 將資料空間內的整數放上資料堆疊 | 程式碼空間
            +---------+       +---------------------------+
        資料 |         | --+
            +---------+   |   +----+
                          +-> | -1 | 資料空間
                              +----+

3.141592653e fconstant my-pi

            +--------------+
        名稱 | my-pi        |
            +--------------+      +-----------------------------+
        行為 | fconst       | ---> | 將資料空間內的浮點數放上浮點堆疊 | 程式碼空間
            +--------------+      +-----------------------------+
        資料 |              | --+
            +--------------+   |   +--------------+
                               +-> | 3.141592653e | 資料空間
                                   +--------------+

```

### 本節指令集
| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `constant <name>` | ( n -- ) &emsp; | constant |
| `2constant <name>` | ( n1 n2 -- ) &emsp; | two-constant |
| `fconstant <name>` | ( F: r -- ) &emsp; | f-constant |

-----------
## 資料空間

我們已見到冒號定義及常數如何使用資料空間。當我們想要設計複雜的資料結構時，必須先瞭解資料空間的特性。以下是我們定義了 `my-false` 、 `my-pi` 、 `range` 及 `in-range` 之後資料空間的示意圖。

```
資料空間

    較低的記憶位址                                    here
    +------+------+------+------+------+------+------+-------------------------
    | 3.141592653e|  4   |  40  | range|within| exit |
    +------+------+------+------+------+------+------+-------------------------
     my-pi         range         in-range             未使用的記憶空間
     8 bytes       4 + 4 bytes
     1 cell        2 cells       3 cells
```

資料依從低到高的次序放進資料空間中。記憶體位址的單位是位元組 (byte) 。但是大多數的資料大小超過一個位元組。比如上圖中的整數佔了 4 位元，浮點數佔了 8 位元。Forth 系統習慣將整數所佔的位元組數目稱為一個單元 (cell)。

| Fort  h | 作業系統 | 資料堆疊上整數所佔位元組數 | 資料空間中整數所佔位元組數 | 浮點數所佔位元組數 | cell 的位元組數 |
|---------|---------|-----------------------|------------------------|-----------------|---------------|
| rtForth | 64 位元 Linux | 8  | 4 | 8 | 4 |
| rtForth | 32 位元 Linux | 4  | 4 | 8 | 4 |
| SwiftForth  | 64 位元 Linux | 4  | 4 | 8 | 4 |
| gforth  | 64 位元 Linux | 8  | 8 | 8 | 8 |

上表中 rtForth 在 64 位元的作業系統下，資料堆疊的整數佔了 8 個位元組，也就是 64 位元。但資料空間中的整數只佔了 4 個位元組，也就是 32 位元。這使得放在資料堆疊上的整數可以比放在資料空間中的整數大得多。將資料堆疊上的整數放進資料空間中時，最高的 32 位元會被截去。如下例，
```
rf> $1234123412341234 constant all
 ok
rf> all h.
12341234  ok
```

由於 32 位元整數能表示的最大整數為 2147483647 。這範圍對工業控制綽綽有餘。此一現象不需要太過顧慮。
```
rf> $7fffffff .
2147483647  ok
```

Forth 指令 `cells` 可以得到一個單元所需的位元組數。
```
rf> 1 cells .
4  ok
```

Forth 指令 `here` 可以得到目前資料空間未使用部份的開始位址，也就是資料空間下一個可以使用的位置。我們先以 `-work  marker -work` 清除自己定義的指令，然後使用 `here .` 檢查一下下一個可以使用的資料空間的位址。然後再定義一個常數看看。
```
rf> -work  marker -work
 ok
rf> here .
1256  ok
rf> -1 constant my-true
 ok
rf> here .
1260  ok
```
因為新定義的指令使用了部份的資料空間。我們發現 `here` 的數值改變了。

我們可以使用指令 `allot` 保留一部份資料空間給我們的程式使用。

```
rf> 1 cells allot  here .
1264  ok
```

指令 `1 cells allot` 保留了一個單元，在此是 4 個位元組。因此 `here` 的值增加了。

指令 `!` 可以用來將一個整數存放在資料空間中某個記憶體位址內。而指令 `@` 可以將指定的記憶體位址內的整數取出放到堆疊上。
```
rf> 1234 1260 !
 ok
rf> 1260 @ .
1234  ok
```
在上例中我們以指令 `!` 將 1234 放進剛剛保留了一個單元的記憶體位址 1260 中。然後再以指令 `@ .` 將位址 1260 內的整數印出來。果然那個位址內的整數是 1234。有一個指令 `?` 的行為就是 `@ .` 。因此我們也可以以下方式將 1260 內的資料印出。
```
rf> 1260 ?
1234  ok
```

指令 `+!` 會將指定位址內的整數加上堆疊上的數字。
```
rf> 1 1260 +!  1260 ?
1235  ok
```

指令 `,` 會配置一個單元的資料空間，然後把資料堆疊疊頂的整數放進這個剛配置的空間中。我們習慣將這種配置記憶體同時填入數值的行為稱為「編譯」。因為编譯指令 `if` 、 ``."` 、 `;` 等都會做類似的事。我們會說指令 `,` 將一個整數「編譯」到字典裡面。
```
rf> 1 , 2 , 3 ,   here .
1276  ok
rf> 1264 ? 1268 ? 1272 ?
1 2 3  ok
```
在上例中我們使用指令 `,` 將 1 、 2 、 3 編譯到字典裡。因為每個整數在資料空間中佔一個單元，我們可以知道每個整數所在的位址，並用指令 `?` 將它們印出來。






此外，資料放進記憶體的開始位址必須符合 CPU 的對齊 (alignment) 規則。

| Forth   | 作業系統 | 整數對齊位址 | 浮點數對齊位址 |
|---------|---------|------------|-------------|
| rtForth | 64 位元 Linux | 4 的倍數 | 8 的倍數 |
| rtForth | 32 位元 Linux | 4 的倍數 | 8 的倍數 |
| SwiftForth | 64 位元 Linux | 4 的倍數 | 8 的倍數 |
| gforth | 64 位元 Linux | 8 的倍數 | 8 的倍數 |

在這個例子中，原本未使用的記憶體從 1096 開始，但以 `1 allot` 配置了一個位元組後，改從 1097 開始。本來 1096 同時符合整數和浮點數的對齊原則。現在不合了，我們可以使用指令 `align` 或 `falign` 修正 here ，重新對齊。

```
rf> align  here .
1100  ok
rf> falign  here .
1104  ok
```

### 本節指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|------------------------------------|--------|
| `cells` | ( -- ) &emsp; | cells |
| `here` | ( -- ) &emsp; | here |
| `allot` | ( -- ) &emsp; | allot |
| `!` | ( n addr -- ) &emsp; 將 n 存在位址 addr  | store |
| `@` | ( addr -- ) &emsp; | fetch |
| `?` | ( addr -- ) &emsp; | question |
| `+!` | ( n addr -- ) &emsp; 將位址 addr 內的整數加 n | plus-store |
| `,` | ( -- ) &emsp; | comma |
| `2@` | ( addr -- n1 n2 ) &emsp; | two-fetch |
| `2!` | ( n1 n2 addr -- ) &emsp; | two-store |
| `f!` | ( addr -- ) ( F: r -- ) &emsp; 將 r 存在位址 addr  | f-store |
| `f@` | ( addr -- ) ( F: -- r ) &emsp; | f-fetch |
| `f,` | ( -- ) &emsp; | f-comma |
| `cell+` | ( -- ) &emsp; | cell+ |
| `align` | ( -- ) &emsp; | align |
| `aligned` | ( -- ) &emsp; | aligned |
| `falign` | ( -- ) &emsp; | f-align |
| `faligned` | ( -- ) &emsp; | f-aligned |

------
## 變數

通常 Forth 的程式在計算過程中會將計算結果放在堆疊上，再以其他指令處理這些結果。有時我們並不想立刻使用這些結果，希望能將結果放在堆疊以外的地方。變數提供了這樣的機制：一塊能存放資料的記憶體空間。Forth 提供了 `variable` 、 `2variable` 及 `fvariable` 等指令讓我們能定義不同種類的變數。

例子：之前的章節提到了亂數產生器。那時我們將亂數的種子放在堆疊上。現在讓我們將種子放在變數裡。

```
: xorshift ( n -- x ) dup 13 lshift xor dup 17 rshift xor dup 5 lshift xor ;
variable seed   2463534242 seed !
: rnd ( n1 -- n2 )   seed @  xorshift  dup seed !  swap mod abs ;
```
以上的 `xorshift` 就是之前的 `xorshift`。我們以 `variable` 定義了一個變數 `seed`，並使用指令 `!` 隨便存了一個整數 2463534242 到這個變數中。之後定了一個指令 `rnd` 使用指令 `@` 從 `seed` 拿出目前的種子，使用 `xorshift` 算出新的種子，複製一份保存在 `seed` 中。然後把這新的種子依前一章的方式求 `n1` 的餘數，並以 `abs` 求正數。

測試一下：

```
rf> 100 rnd .
47  ok
rf> 100 rnd .
11  ok
rf> 100 rnd .
77  ok
```

### 本節指令集
| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `variable <name>` | ( -- ) &emsp; | variable |
| `2variable <name>` | ( -- ) &emsp; | two-variable |
| `fvariable <name>` | ( -- ) &emsp; | f-variable |

-------------------
## 定義自己的資料結構

CREATE

### 本節指令集
| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `create <name>` | ( -- ) &emsp; | create |
| `does>` | ( -- ) &emsp; | does |
| `+field` | ( -- ) &emsp; | pluse-field |

-------------
## 本章重點整理

* 字典 (dictionary)
* 變數 (variable)
* 常數 (constant)
* 單元 (cell)
* 資料空間 (data space)
* 程式碼空間 (code space)
* 標記指令 (marker)

-----------
## 本章指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|------------------------------------|--------|
| `+field` | ( -- ) &emsp; | pluse-field |
