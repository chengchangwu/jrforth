# 字典

Forth 系統核心的資料結構有二：

* 堆疊：參數堆疊、浮點堆疊，以及本書未深入提及的返回堆疊。指令和指令之間的資料透過堆疊傳遞。
* 字典：記錄 Forth 所有的指令。提供文本解譯器查尋及執行指令的功能。

在之前的章節，我們花了許多篇幅熟悉堆疊的操作。以及熟悉眾多指令中的一種：冒號定義指令。在這章我們把重點放在字典，在字典中增加新的指令的方法，以及指令存放在字典中的方式。

想在字典中增加新的指令，可以使用「定義指令」。冒號就是一種定義指令。以下是我們將在這章學到的定義指令：

* 定義字典標記： `marker`
* 定義常數：`constant` 、 `2constant` 、 `fconstant`
* 定義變數：`variable` 、 `2variable` 、 `fvariable`
* 定義資料結構：`create` 、 `+field`

我們也將學習如何使用字典中的資料空間。

## 指令 words

Forth 能執行 `+` 、 `-` 、`*` 、 `/` 這些指令，是因為它內建的字典 (dictionary) 提供了搜尋及執行指令的功能。如果我們想知道字典中有多少指令，我們可以執行指令 `words`。

```
rf> words

-work (abort) quit evaluate >in source tib #tib fill c, min
max +! 2variable 2! 2@ align aligned spaces space bl cr
?dup f> >= <= h. hex decimal accept 1/sec hz rpm um/msec
mm/min usec msec sec minute hr rad deg um mm meter fnegate
fceil fround floor fmax fmin f< f0= f0< f~ f** f/ f* f- f+
...
```

字典記載了指令的名稱、行為、資料，並提供搜尋指令的方法。

```
指令
            +------+
        名稱 |  +   |
            +------+      +-----------------+
        行為 | plus | ---> | 將堆疊上的數字相加 | 程式碼空間
            +------+      +-----------------+
        資料 | 無   |
            +------+

字典
            +--------+      +---------+      +------+      +----------+
  LAST ---> | -work  | ---> | (abort) | ---> | quit | ---> | evaluate | --->
            +--------+      +---------+      +------+      +----------+
            | unmark |      | nest    |      | nest |      | nest     |
            +--------+      +---------+      +------+      +----------+
            |        |      |         |      |      |      |          |
            +--------+      +---------+      +------+      +----------+
```

指令 `words` 先顯示較晚定義的指令，再顯示較早定義的指令。以之前的例子來看，指令 `-work` 是最後一個定義的指令，再來是 `(abort)`，再來是 `quit`。示義圖中，LAST 指的是最後一個定義的指令，也就是 `-work`。它是一個之後會提到的字典標記指令，執行它時，它的行為是 `unmark`。其他的幾個指令的行為是 `nest`。行為是 `nest` 的指令就是我們之前提到的冒號定義指令。

現在讓我們定義本書的第一個指令 `hello`。看看字典有什麼變化。

```
rf> : hello ." Hello World!" ;
 ok
rf> words

hello -work (abort) quit evaluate >in source tib #tib fill
c, min max +! 2variable 2! 2@ align aligned spaces space bl
...
```

可以看到 `words` 顯示的最後一個指令是剛才定義的 `hello`。

```
: hello   ." Hello World!" ;

            +-------+                                  +-------+
LAST -> 名稱 | hello | -------------------------------> | -work | ---> 
            +-------+        +---------------+         +-------+
        行為 | nest  | -----> | 執行冒號定義指令 | 程式碼空間
            +-------+        +---------------+
        資料 |       | --+
            +-------+   |    +-----+----+--------------+------+------+
                        +--> | _s" | 12 | Hello World! | type | exit | 資料空間
                             +-----+----+--------------+------+------+
```

從圖中可以看出指令的行為被放在程式碼空間 (code space) 中，資料則放在資料空間 (data space) 中。
這兒所謂的空間，就是一塊連續的記憶體。程式碼空間放的是可以執行的機器語言程式碼。資料空間中放的則是機器語言程式碼執行時所需的資料。某些系統裡將機器語言程式碼和資料放在同一個空間裡。在另外一些系統中，存放名稱、行為、資料的那個資料結構被放在另一個名為標頭空間 (header space) 的記憶體中。

上圖中的 `nest` 對應的是執行冒號定義指令的機器語言程式碼。它會取得資料空間中的 Forth 指令依順序執行。第一個指令 `_s"` 會將長度為 12 的字串 "Hello World!" 的開始位置和長度放在堆疊上。其後的 `type` 則會依據堆疊上的位置和長度印出字串的內容。這兒的 `_s"` 和其後的數字和字串，以及 `type` ，都是编譯指令 `."` 编譯進字典中的。例中顯示的只是 rtForth 的編譯結果。不同的 Forth 系統有不同的编譯方式。指令 `_s"` 不是 Forth 2012 的標準指令。但是 `type` 是一個標準指令。

另有一個編譯指令 `s"` 類似 `.s"` 但只編譯上例中的 `_s"` 及其後字串的部份，不編譯 `type`。因此以下兩個冒號定義指令的效果是一樣的：

```
: hello-1   ." Hello World!" ;
: hello-2   s" Hello World!" type ;
```

### 本節指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `words` | ( -- ) &emsp; 顯示字典中目前能使用的指令 | words |
| `s" <string>"` | ( -- ) &emsp;  編譯其後的字串直到下一個 "。 | s-quote |
| `type` | ( addr n -- ) &emsp; 印出資料空間位置 addr 處，長度為 n 的字串 | type |

-------------------
## 標記指令 (Marker)

當你使用 rtForth，不想保留自己定義的指令時，可以執行 `-work。
```
rf> -work
 ok
rf> words

(abort) quit evaluate >in source tib #tib fill c, min max
+! 2variable 2! 2@ align aligned ...
```
你會發現，不只是剛剛定義的 `hello` 不見了，連 `-work` 也不見。

指令 `-work` 標記了字典的特定位置 (包括定義 -work 時資料空間和程式碼空間的位置)。執行時，會丟棄指令本身以及其後的所有指令，並且歸還這些指令使用的資料空間和程式碼空間。

你可以使用 `marker` 定義這類標記指令。

```
rf> marker -work
 ok
rf> words

-work (abort) quit evaluate >in source tib #tib fill c, min
max +! 2variable 2! 2@ align aligned ...
```

於是一個新的 `-work 又出現了。

指令 `-work` 並不是 Forth 2012 的標準指令。但是 `marker` 是一個標準指令。它的主要用處是標記字典的特定位置，以便在必要時移除一群指令。

### 例子：CNC 工具機

CNC 工具機內有兩種不同類型的程式：PLC 程式，也就是所謂的階梯圖，處理機器內各種裝置的開關，以及工件程式，也就是所謂的 G 代碼，處理馬達的運動和加工行為。這兩種不同的程式，都可以透過編譯器翻譯成 Forth 指令。例如 PLC 程式可以翻譯成一個 Forth 指令 `run-plc`。工件程式可以翻譯成 Forth 指令 `run-nc`。這兩個指令都放在字典中。

Forth 本身是一個多工的系統。因此可以使用一個 Task 執行 `run-plc`，另一個 Task 執行 `run-nc`。下一章會說明 rtForth 的多工環境。

一台機器的 PLC 程式通常是不變的，開機時就載入的。但機台製造商的維護的人員有權限修改它。而工件程式則是操作員選擇後才載入的，很可能一天要換好幾個工件程式。因此我們可以用 marker 對字典進行以下的規畫：

Forth 程式一：定義不隨工件程式和 PLC 變動的指令。在開機時載入。
```
\ 定義不隨 PLC 和工件程式變動的指令。
: xxx ... ;

\ 定義 PLC 和 工件程式的 markers。一開始 PLC 程式和工件程式都是空的。
marker -plc
marker -nc
```

Forth 程式二：PLC 程式。在開機時載入，或在維護人員修改 PLC 程式時載入。
```
\ 清除之前的 PLC 程式
-plc   marker -plc

: run-plc   ... ;

\ 定義工件程式的 markers。目前工件程式是空的。
marker -nc
```

Forth 程式三：工件程式，在操作員選擇加工程式時載入。
```
-nc   marker -nc

: run-nc   ... ;
```

如此，當維護人員要修改 PLC 程式時，指令 `-plc` 會清除 PLC 程式以及之後的工件程式。並定義新的 `-plc` 和 `-nc` 這兩個 markers。當操作員要下載新的工件程式時，指令 `-nc` 會清除舊的工件程式，並定義新的 `-nc` marker。

### 本節指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `marker <name>` | ( -- ) &emsp;  | marker |

-----------
## 常數
像 `true` 、 `false` 和 `pi` 這類被賦與固定數值的指令，被稱為常數。Forth 定義整數常數的方法如下：
```
<整數> constant <常數名>
<整數> <整數> 2constant <常數名>
<浮點數> fconstant <常數名>
```
指令 `constant` 從堆疊上取得整數，從輸入緩衝區取得跟在它後面的名稱，然後在字典裡建立了一個同名的常數。指令 `fconstant` 的行為類似，但定義的是浮點數常數。而 `2constant` 則從堆疊上取得兩個整數，為它們定義了一個常數。

例一：定義自己的真、假、圓週率常數
```
rf> -1 constant my-true
 ok
rf> 0 constant my-false
 ok
rf> 3.141592653e fconstant my-pi
 ok
rf> my-true .  my-false .  my-pi f.
-1 0 3.1415927  ok
```

例二：某機器只能大於或等於 4&deg;C ，小於 40&deg;C 時工作，超過就要停機，請將 4 和 40 這組數字定為一常數 `range` 並以 `within` 分別判斷 3 度、20 度及 40 度是否落在機器可以工作的範圍內。

```
4 40 2constant range
: in-range ( n -- )   range within ;
```

以下是使用 `constant` 和 `fconstant` 定義出來的指令在字典中的示意圖。

```
-1 constant my-true

            +---------+
        名稱 | my-true |
            +---------+       +---------------------------+
        行為 | const   | ----> | 將資料空間內的整數放上資料堆疊 | 程式碼空間
            +---------+       +---------------------------+
        資料 |         | --+
            +---------+   |   +----+
                          +-> | -1 | 資料空間
                              +----+

3.141592653e fconstant my-pi

            +--------------+
        名稱 | my-pi        |
            +--------------+      +-----------------------------+
        行為 | fconst       | ---> | 將資料空間內的浮點數放上浮點堆疊 | 程式碼空間
            +--------------+      +-----------------------------+
        資料 |              | --+
            +--------------+   |   +--------------+
                               +-> | 3.141592653e | 資料空間
                                   +--------------+

```

### 本節指令集
| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `constant <name>` | ( n -- ) &emsp; | constant |
| `2constant <name>` | ( n1 n2 -- ) &emsp; | two-constant |
| `fconstant <name>` | ( F: r -- ) &emsp; | f-constant |

-----------
## 資料空間

我們已見到冒號定義及常數如何使用資料空間。當我們想要設計複雜的資料結構時，必須先瞭解資料空間的特性。以下是我們定義了 `my-false` 、 `my-pi` 、 `range` 及 `in-range` 之後資料空間的示意圖。

```
資料空間

    較低的記憶位址                                    here
    +------+------+------+------+------+------+------+-------------------------
    | 3.141592653e|  4   |  40  | range|within| exit |
    +------+------+------+------+------+------+------+-------------------------
     my-pi         range         in-range             未使用的記憶空間
     8 bytes       4 + 4 bytes
     1 cell        2 cells       3 cells
```

資料依從低到高的次序放進資料空間中。記憶體位址的單位是位元組 (byte) 。但是大多數的資料大小超過一個位元組。比如上圖中的整數佔了 4 位元，浮點數佔了 8 位元。Forth 系統習慣將整數所佔的位元組數目稱為一個單元 (cell)。

| Fort  h | 作業系統 | 資料堆疊上整數所佔位元組數 | 資料空間中整數所佔位元組數 | 浮點數所佔位元組數 | cell 的位元組數 |
|---------|---------|-----------------------|------------------------|-----------------|---------------|
| rtForth | 64 位元 Linux | 8  | 4 | 8 | 4 |
| rtForth | 32 位元 Linux | 4  | 4 | 8 | 4 |
| SwiftForth  | 64 位元 Linux | 4  | 4 | 8 | 4 |
| gforth  | 64 位元 Linux | 8  | 8 | 8 | 8 |

上表中 rtForth 在 64 位元的作業系統下，資料堆疊的整數佔了 8 個位元組，也就是 64 位元。但資料空間中的整數只佔了 4 個位元組，也就是 32 位元。這使得放在資料堆疊上的整數可以比放在資料空間中的整數大得多。將資料堆疊上的整數放進資料空間中時，最高的 32 位元會被截去。如下例，
```
rf> $1234123412341234 constant all
 ok
rf> all h.
12341234  ok
```

由於 32 位元整數能表示的最大整數為 2147483647 。這範圍對工業控制綽綽有餘。此一現象不需要太過顧慮。
```
rf> $7fffffff .
2147483647  ok
```

Forth 指令 `cells` 可以得到一個單元所需的位元組數。
```
rf> 1 cells .
4  ok
```

指令 `floats` 則可以得到一個浮點數所需的位元組數。
```
rf> 1 floats .
8  ok
```

另外 Forth 還提供了指令 `cell+` 和 `float+`，可以將堆疊上的數字加上一個單元的位元組數或一個浮點數的位元組數。

```
rf> 1 cell+ .  1 float+ .
5 9  ok
```

### 一個單元的資料空間指令

Forth 指令 `here` 可以得到目前資料空間未使用部份的開始位址，也就是資料空間下一個可以使用的位置。我們先以 `-work  marker -work` 清除自己定義的指令，然後使用 `here .` 檢查一下下一個可以使用的資料空間的位址。然後再定義一個常數看看。
```
rf> -work  marker -work
 ok
rf> here .
1256  ok
rf> -1 constant my-true
 ok
rf> here .
1260  ok
```
因為新定義的指令使用了部份的資料空間。我們發現 `here` 的數值改變了。

你使用的 Forth 系統在清除了自己定義的指令後，`here` 的位置可能和本書例子中的不一致。嘗試以下例子時請依據自己系統的情形修改輸入的數值。

我們可以使用指令 `allot` 保留一部份資料空間給我們的程式使用。

```
rf> 1 cells allot  here .
1264  ok
```

指令 `1 cells allot` 保留了一個單元，在此是 4 個位元組。因此 `here` 的值增加了。

指令 `!` 可以用來將一個整數存放在資料空間中某個記憶體位址內。而指令 `@` 可以將指定的記憶體位址內的整數取出放到堆疊上。
```
rf> 1234 1260 !
 ok
rf> 1260 @ .
1234  ok
```
在上例中我們以指令 `!` 將 1234 放進剛剛保留了一個單元的記憶體位址 1260 中。然後再以指令 `@ .` 將位址 1260 內的整數印出來。果然那個位址內的整數是 1234。有一個指令 `?` 的行為就是 `@ .` 。因此我們也可以以下方式將 1260 內的資料印出。
```
rf> 1260 ?
1234  ok
```

指令 `+!` 會將指定位址內的整數加上堆疊上的數字。
```
rf> 1 1260 +!  1260 ?
1235  ok
```

指令 `,` 會配置一個單元的資料空間，然後把資料堆疊疊頂的整數放進這個剛配置的空間中。我們習慣將這種配置記憶體同時填入數值的行為稱為「編譯」。因為编譯指令 `if` 、 ``."` 、 `;` 等都會做類似的事。我們會說指令 `,` 將一個整數「編譯」到字典裡面。
```
rf> 1 , 2 , 3 ,   here .
1276  ok
rf> 1264 ? 1268 ? 1272 ?
1 2 3  ok
```
在上例中我們使用指令 `,` 將 1 、 2 、 3 編譯到字典裡。因為每個整數在資料空間中佔一個單元，我們可以知道每個整數所在的位址，並用指令 `?` 將它們印出來。

### 雙單元的資料空間指令

指令 `!` 和 `@` 存取一個單元的資料空間。Forth 也提供了 `2!` 和 `2@` 兩個指令用來存取兩個單元的資料空間。

請進行以下練習：

```
rf> -work   marker -work   here .
1256  ok
rf> 2 cells allot   here .
1264  ok
rf> 1 2 1256 2!  .s
 ok
rf> 1256 2@  .s
1 2  ok
rf> 1256 @  1260 @  .s
1 2 2 1  ok
rf> xx
xx Undefined word
```
我們先清除自行定義的指令，以 `allot` 配置兩個單元的資料空間。將整數 1、2 以 `2!` 放入配置的記憶體。以 `2@` 取出。期間我們使用 `.s` 來檢查堆疊是否如我們預期。我們還使用 `@` 依序取出這兩個單元的內容。我們發現堆疊上 ( 1 2 ) 這兩筆資料被放進字典的次序是先把疊頂的 2 放進低位址 1256 的記憶體內，再把底下的 1 放在高位址 1260 的記憶體內。最後我們執行文本直譯器不認得的指令 `xx` 以清除堆疊。

Forth 2012 標準並未提供相當於指令 `,` 的雙單元的編譯指令 `2,`。但 rtForth 和 gforth 都有提供。使用 SwiftForth 的人可以可以自行定義一個如下：
```
\ 將 n1 n2 編進字典裡
: 2, ( n1 n2 -- )   here  2 cells allot  2! ;
```

### 對齊

資料放進記憶體的開始位址應符合 CPU 的對齊 (alignment) 規則。比如 32 位元的整數因為是由 4 個位元組構成，應該放在開始位址是 4 的倍數的地方。而 64 位元的浮點數則應放在開始址址是 8 的倍數的地方。這方便 CPU 的資料匯流排 (data bus) 一次就存取所有的資料。如果資料沒對齊它該有的位址，因為無法一次存取，指令執行的性能變差。甚至在某些 CPU 會無法正確取得資料。在 ARMv7 以上的版本以及 Intel 的 CPU 上，資料都能正確存取。就是性能需要注意。

| Forth   | 作業系統 | 整數對齊位址 | 浮點數對齊位址 |
|---------|---------|------------|-------------|
| rtForth | 64 位元 Linux | 4 的倍數 | 8 的倍數 |
| rtForth | 32 位元 Linux | 4 的倍數 | 8 的倍數 |
| SwiftForth | 64 位元 Linux | 4 的倍數 | 8 的倍數 |
| gforth | 64 位元 Linux | 8 的倍數 | 8 的倍數 |

指令 `aligned` 及 `faligned` 分別調整疊頂的整數使其符合整數及浮點的對齊原則。

例子：
```
rf> 0 aligned .   1 aligned .
0 4  ok
rf> 0 faligned .   1 faligned .
0 8  ok
```
上例中因為 1 不符合對齊原則而被 `aligned` 及 `faligned` 調整為符合的數值。

指令 `align` 和 `falign` 則分別調整 `here` 的回傳值使其符合整數及浮點數的對齊原則。

例子：
```
rf> here .
1312  ok
rf> 1312 aligned .   1312 faligned .
1312 1312  ok
rf> 1 allot  here .
1313  ok
rf> 1313 aligned .   1313 faligned .
1316 1320  ok
rf> align  here .
1316  ok
rf> falign  here .
1320  ok
```
上例中 1312 符合對齊原則。將過 `1 allot` 後，`here` 變成 1313，不符合對齊原則。我們以 `align` 修正使得 here 變成符合整數對齊原則的 1316，之後又以 `falign` 修正使其變成符合浮點數對齊原則的 1320。

### 浮點數的資料空間指令

類似 `!` 、 `@` 和 `,`，Forth 提供了浮點數的版本： `f!` 、`f@` 、 `f,` 。
因為 `f,` 不是 Forth 2012 標準，如果你的系統沒有 `f,`，可以定義 `f,` 如下：
```
: f, ( F: r -- )   here  1 floats allot  f! ;
```

請進行以下練習：

```
rf> -work  marker -work  here .
1344  ok
rf> falign here .
1344  ok
rf> 1 floats allot   1e 1344 f!
 ok
rf> 1344 f@ f.
1.0000000  ok
rf> 3 ,  falign  1e f,  2e f,  3e f,
 ok
rf> 1344 float+  dup ?  cell+ faligned dup f@ f.  float+ dup f@ f.  float+ dup f@ f.
3 1.0000000 2.0000000 3.0000000  ok
```

在練習中，我們先以 `falign` 調整 `here` 的位置。然後使用 `1 floats allot` 配置一個浮點數大小的空間，再使用 `f!` 把浮點數 1.0 放進了這個空間。之後使用 `f@` 取出並以 `f.` 印出，確認數值是正確的。之後我們編譯了一個大小為三的浮點數陣列到字典中。首先我們使用 `3 ,` 先編譯了這個陣列的大小，也就是 3。因為這個編譯行為會造成 `here` 不再對齊浮點數所需的位址。所以我們使用 `falign` 調整 `here`，之後再以 `1e f, 2e f, 3e f,` 將三個浮點數編譯到字典中。

要取出那陣列的資料時，我們使用 `1344 float+` 先跳過最早之前使用 `f!` 存放的那個數。然後印出陣列的長度，再以 `cell+ faligned` 跳過陣列的長度到下一個對齊浮點數的位址，以 `f@ f.` 印出，再以 `float+ dup f@ f.` 跳過這個浮點數並印出下一個。

經過這個的練習應該能瞭解如何使用 `faligned` 和 `falign`。這對之後要自行定義有浮點數的資料結構時會有幫助。

### 本節指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|------------------------------------|--------|
| `cells` | ( -- ) &emsp; | cells |
| `cell+` | ( -- ) &emsp; | cell+ |
| `floats` | ( -- ) &emsp; | floats |
| `float+` | ( -- ) &emsp; | float+ |
| `here` | ( -- ) &emsp; | here |
| `allot` | ( -- ) &emsp; | allot |
| `!` | ( n addr -- ) &emsp; 將 n 存在位址 addr  | store |
| `@` | ( addr -- ) &emsp; | fetch |
| `?` | ( addr -- ) &emsp; | question |
| `+!` | ( n addr -- ) &emsp; 將位址 addr 內的整數加 n | plus-store |
| `,` | ( -- ) &emsp; | comma |
| `2@` | ( addr -- n1 n2 ) &emsp; | two-fetch |
| `2!` | ( n1 n2 addr -- ) &emsp; | two-store |
| `2,` | ( n1 n2 -- ) &emsp; | two-comma |
| `f!` | ( addr -- ) ( F: r -- ) &emsp; 將 r 存在位址 addr  | f-store |
| `f@` | ( addr -- ) ( F: -- r ) &emsp; | f-fetch |
| `f,` | ( -- ) &emsp; | f-comma |
| `align` | ( -- ) &emsp; | align |
| `aligned` | ( -- ) &emsp; | aligned |
| `falign` | ( -- ) &emsp; | f-align |
| `faligned` | ( -- ) &emsp; | f-aligned |

------
## 變數

如果我們想為我們配置好的記憶體取個名字。我們可以使用 constant。例如：

```
rf> here  1 ,  constant the-one
 ok
rf> the-one ?
1  ok
```

因為常有需要對配置的記憶體命名的需求，Forth 提供了變數定義指令`variable` 、 `2variable` 及 `fvariable`。

通常 Forth 的程式在計算過程中會將計算結果放在堆疊上，再以其他指令處理這些結果。有時我們並不想立刻使用這些結果時，可以把結果放在變數中，需要時才拿出來使用。

例子：之前的章節提到了亂數產生器。那時我們將亂數的種子放在堆疊上。現在讓我們將種子放在變數裡。

```
: xorshift ( n -- x ) dup 13 lshift xor dup 17 rshift xor dup 5 lshift xor ;
variable seed   2463534242 seed !
: rnd ( n1 -- n2 )   seed @  xorshift  dup seed !  swap mod abs ;
```
以上的 `xorshift` 就是之前的 `xorshift`。我們以 `variable` 定義了一個變數 `seed`，並使用指令 `!` 隨便存了一個整數 2463534242 到這個變數中。之後定了一個指令 `rnd` 使用指令 `@` 從 `seed` 拿出目前的種子，使用 `xorshift` 算出新的種子，複製一份保存在 `seed` 中。然後把這新的種子依前一章的方式求 `n1` 的餘數，並以 `abs` 求正數。

測試一下：

```
rf> 100 rnd .
47  ok
rf> 100 rnd .
11  ok
rf> 100 rnd .
77  ok
```

### 本節指令集
| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `variable <name>` | ( -- ) &emsp; | variable |
| `2variable <name>` | ( -- ) &emsp; | two-variable |
| `fvariable <name>` | ( -- ) &emsp; | f-variable |

-------------------
## 定義自己的資料結構

CREATE

### 向量執行

### 本節指令集
| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `create <name>` | ( -- ) &emsp; | create |
| `does>` | ( -- ) &emsp; | does |
| `+field` | ( -- ) &emsp; | pluse-field |
| `execute` | ( -- ) &emsp; | execute |
| `'` | ( -- ) &emsp; |  |
| `[']` | ( -- ) &emsp; | |

-------------
## 本章重點整理

* 字典 (dictionary)
* 變數 (variable)
* 常數 (constant)
* 單元 (cell)
* 資料空間 (data space)
* 程式碼空間 (code space)
* 標記指令 (marker)
* 向量執行 (vector execution)

-----------
## 本章指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|------------------------------------|--------|
| `+field` | ( -- ) &emsp; | pluse-field |
