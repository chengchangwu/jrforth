# 比較及邏輯運算

## 十進制、二進制、十六進制

人的十根手指頭，決定了人類使用十進制的數字系統。電腦由數量龐大的微型開關構成，只懂開關，或是 0 與 1，使用的是二進制系統。
為了以更簡捷的方式來閱讀二進制系統，人們將二進制中的數字每四位一組，形成了 16 進制。

| 十進制 | 二進制 | 十六進制 |
|------:|------:|--------:|
| 0     | 0     | 0       |
| 1     | 1     | 1       |
| 2     | 10    | 2       |
| 3     | 11    | 3       |
| 4     | 100   | 4       |
| 5     | 101   | 5       |
| 6     | 110   | 6       |
| 7     | 111   | 7       |
| 8     | 1000  | 8       |
| 9     | 1009  | 9       |
| 10    | 1010  | A       |
| 11    | 1011  | B       |
| 12    | 1100  | C       |
| 13    | 1101  | D       |
| 14    | 1110  | E       |
| 15    | 1111  | F       |

本文中以下標來表示數字的進制。如 11<sub>10</sub> 代表 10 進制的 11。11<sub>16</sub> 代表 16 進制的 11。11<sub>2</sub> 代表 2 進制的 11。

Forth 使用 `decimal` 、`binary` 、 `hex` 這三個指令切換十進制、二進制和十六進制。

指令 `binary` 不是 Forth 2012 標準中的指令。但 rtForth 內建了這個指令。如果你使用的 Forth 沒有 `binary`，可以輸入以下命令定義這個指令，注意不要遺漏任何一個空格：

```
: binary  2 base ! ;
```

例一：以二進制顯示 11<sub>10</sub>。
```
rf> 11  binary .  decimal
1011  ok
```
在上面例子中，因為系統預設為以十進制輸入和顯示數字，11 是十進制的 11<sub>10</sub> 。`binary .` 將輸出入切換到二進制再印出 11<sub>10</sub>，得到 1011<sub>2</sub>。再以 `decimal` 切換為預設的十進制。

例二：以十進制顯示十六進制的 11<sub>16</sub>。
```
rf> hex 11 decimal .
17  ok
```
在上面例子中，因為系統預設為以十進制輸入和顯示數字，先以 `hex` 切換輸出入為十六進制，所以 11 是十六進制的 11<sub>16</sub> 。`decimal .` 則將輸出入切換到十進制再印出 11<sub>16</sub>，得到 17<sub>10</sub>。此時系統已回到預設的十進制。

例三：以二進制印出 -1<sub>10</sub> 和 -2<sub>10</sub>。
```
rf> -1 binary .  decimal
1111111111111111111111111111111111111111111111111111111111111111  ok
rf> -2 binary .  decimal
1111111111111111111111111111111111111111111111111111111111111110  ok

```
在此我們看到負數在電腦中是如何用 0 和 1 表示的。若仔細算算，會發現 -1<sub>10</sub> 的二進制顯示了 64 個 1。 因為這書使用的是 64 位元的作業系統。 如果使用 32 位元的作業系統，我們會看到 32 個 1 。

## 本節指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `decimal` | ( -- ) &emsp; 切換數字輸出入為十進制   | decimal |
| `hex`     | ( -- ) &emsp; 切換數字輸出入為十六進制 | hex |
| `binary`  | ( -- ) &emsp; 切換數字輸出入為二進制   | binary |

## 真和假

電腦也用 0 和 1 表示真假。Forth 指令 `true` 和 `false` 將真和假放上資料堆疊，讓我們看看它倆的二進制表示法：

例四：以二進制印出 `true` 和 `false` 。
```
rf> true binary . decimal
1111111111111111111111111111111111111111111111111111111111111111  ok
rf> false binary . decimal
0  ok
```
所以 0 不只是十進制的 0<sub>10</sub>，也用來表示假 (false)。而 64 個 1 不只是十進制的 -1<sub>10</sub>，也表示真 (true) 。

這和許多語言不同，C 語言的 true 是 1 。Forth 以 -1 為真，在進行位元運算時有其好處。請見位元運算一節。

| 指令 | 堆疊效果及指令說明                       | 口語唸法 |
|-----|---------------------------------------|--------|
| `true`  | ( -- true ) &emsp; 回傳一所有位元都為 1 的整數 | true |
| `false` | ( -- false ) &emsp; 回傳一所有位元都為 0 的整數 | false |

## 整數比較

Forth 有許多指令的結果是真或假。其中大宗就是比較指令。在整數部份，Forth 提供了跟 0 比較的指令，以及比較兩個整數的指令。請參考本節的指令集並練習以下例子。

例五：使用 `0<` `0=` `0>` `0<>` 比較 -1 、 0 、 1 和 0 的關係。
```
rf> -1 0< .  0 0= .  1 0> .
-1 -1 -1  ok
rf> 0 0<> .
0  ok
```
所以 -1 < 0， 0 = 0， 1 > 0 且 0 不會不等於 0。

例六：使用 `<` `=` `<>` `>` 比較 2 、 6 、 8 和 6 之間的關係。
```
rf> 2 6 < .  6 6 = .  6 6 <> .  8 6 > .
-1 -1 0 -1  ok
```
所以 2 < 6， 6 = 6， 6 不會不等於 6， 8 大於 6。

### 本節指令集

| 指令 | 堆疊效果及指令說明                       | 口語唸法 |
|-----|---------------------------------------|--------|
| `0<`    | ( n -- flag ) &emsp; 當 n < 0 時 flag 為真 | zero-less |
| `0=`    | ( n -- flag ) &emsp; 當 n = 0 時 flag 為真 | zero-equals |
| `0<>`   | ( n -- flag ) &emsp; 當 n 為不 0 時 flag 為真 | zero-not-equals |
| `0>`    | ( n -- flag ) &emsp; 當 n > 0 時 flag 為真 | 0-greater |
| `<`     | ( n1 n2 -- flag ) &emsp; 當 n1 < n2 時 flag 為真 | less-than |
| `=`     | ( n1 n2 -- flag ) &emsp; 當 n1 = n2 時 flag 為真 | equals |
| `>`     | ( n1 n2 -- flag ) &emsp; 當 n1 > n2 時 flag 為真 | greater-than |
| `<>`    | ( n1 n2 -- flag ) &emsp; 當 n1 不等於 n2 時 flag 為真 | not-equals |

## 浮點數比較

不熟悉浮點數的人最容易犯的錯，就是採用錯誤的方式判斷浮點數是否相等。本節先說明比較相等時可能遇上的問題。

* 浮點數不是實數，只是近似實數。這近似會有誤差。比如 0.15 + 0.15 和 0.2 + 0.1 從實數觀點來看都應該得到 0.3。但是不幸的，因為浮點運算的誤差很可能得到的只是一個很接近 0.3 的數。
* 浮點數的編碼，+0 和 -0 有不同的編碼。但是都是 0。因此用編碼相等的方式判斷會有 0 不等於 0 的問題。
* 浮點數的 NaN (Not a Number) 可以用 0.0 / 0.0 產生。但也可以用 &infin; &times; 0 產生。同樣是 NaN，但不應該認為這兩種方式產生的數字是相等的。
* 浮點數的編碼方式，在 0.0 的附近能表達的數字很密，遠離 0.0 的地方數字稀疏。因此對靠近 0.0 的地方可以進行較精密的判斷。同離 0.0 的地方則不行。

因此 Forth 並未提供 `f=` 這樣的指令，以免誤用。
Forth 提供了指令 `f~` 用來比較浮點數是否近似。它是個比較複雜的指令，有三種比較方式。
* 絕對似近，當堆疊為 ( r1 r2 r3 ) ，且 r3 > 0 時，判斷是否 |r1-r2| < r3 。
* 相對似近，當堆疊為 ( r1 r2 r3 ) ，且 r3 < 0 時，判斷是否 |r1-r2| < |r3*(|r1|+|r2|)|。
* 編碼相等，當堆疊為 ( r1 r2 r3 ) ，且 r3 = 0 時，判斷是否 r1 和 r2 的編碼相等。要注意就算是在同一台電腦上，不同的 Forth 系統對於「編碼相等」的解釋很可能不同。

不同的判斷方式有不同的適用場合。

### 以 f~ 比較編碼相等

適用場合：用於二分逼進法最後的停止條件。當重覆得到同一編碼時終止計算。

以下幾個例子，我們利用比較編碼相等的方式，來熟悉浮點數的特性。

例七：0.15 + 0.15 和 0.2 + 0.1 都會得到 0.3 ，請以 `f~` 檢查其編碼是否相等。
```
rf> 0.15e 0.15e f+  0.2e 0.1e f+  0.0e f~ .
0  ok
```
使用 Intel 64bit 的 rtForth 得到的答案是不相等。

例八： 0.0 / 0.0 會得到 NaN，依照 NaN 的規則，NaN 不等於 NaN。但 NaN 的編碼應是一樣的。以下分別以 rtForth 、 SwiftForth 和 gforth 使用 `f~` 測試 NaN 是否等於 NaN。

使用 rtForth
```
rf> 0e 0e f/ 0e 0e f/ 0e f~ .
0  ok
```

使用 gforth
```
0e 0e f/ 0e 0e f/ 0e f~ . -1  ok
```

使用 SwiftForth
```
0e 0e f/ 0e 0e f/ 0e f~ . 0
```

可以看出不同版本的 Forth 對於 Forth 2012 中「編碼應是一樣的」有不同的詮釋。gforth 符合標準，卻不符合 NaN 不等於 NaN 的原則。

### 以 f~ 判斷是否絕對近似

適用場合：當兩個浮點數差的絕對值必須小於某固定值時。比如量測設備的量測容許誤差

例九：某量測儀器會進行三次量測再求平均。若三次量測結果和平均值距離大於 2.5 微米就會重新量測。當三次量測結果分別是 1032 微米 、 1035 微米 、 1037 微米時是否要重新量測？
```
rf> 1032e 1035e 1037e f+ f+ 3e f/ f.
1034.6666667  ok
rf> 1032e 1034.666e 2.5e f~ .
0  ok
rf> 1035e 1034.666e 2.5e f~ .
-1  ok
rf> 1037e 1034.666e 2.5e f~ .
-1  ok
```
因為 1032 微米和平均值差太多，所以要重新量測。

### 以 f~ 判斷是否相對近似

適用場合：
* 進行數值運算時，可能因演算法未考慮浮點數的誤差而導至運算過程中失去太多的精度。相對比較適合用來分析這類情況。
* 當在意的是兩浮點數差的相對值時。比如一般人會認為 1.0001 公尺和 1.0002 公尺差不多。但會認為 1.1 公釐和和 1.2 公釐差很多。雖然兩者都只差 0.1 公釐。 

注意事項：被判斷是否相對近似的兩個數都是 0.0 時，依相對判斷的數學式 |r1-r2| < |r3*(|r1|+|r2|) 會得到 0.0 < 0.0，也就是假這個有點怪的結果。

例十：正切函式在 &pi; / 2 附近變化很大。以 `f~` 確定 1.55 和 1.56 的相對近似度可達 1%，但是 tan(1.55) 和 tan(1.56) 的相對近似度不到 30%，落在 30% 和 40% 之間。
```
rf> 1.55e  1.56e  -0.01e f~ .
-1  ok
rf> 1.55e ftan  1.56e ftan  -0.3e f~ .
0  ok
rf> 1.55e ftan  1.56e ftan  -0.4e f~ .
-1  ok
```

例十一：判斷 0.0 是否相對近似於 0.0 ？
```
rf> 0e 0e -0.5e f~  .
0  ok
```

### 其他浮點比較指令

除了判斷近似的 `f~`，Forth 還另有 `f0=` 、 `f0<` 和 `f<`。

指令 `f0=` 判斷浮點數是否為 0.0。指令 `f0<` 判斷浮點數是否小於 0.0。`f<` 則判斷兩個浮點數之間的大小關係。

例十二：cos(1) 是否小於 0.0？ sin(0) 是否等於 0.0？
```
rf> 1e fcos f0< .
0  ok
rf> 0e fsin f0= .
-1  ok
```
所以 cos(1) 不小於 0.0，且 sin(0) = 0.0。

例十三：cos(1) 是否小於 0.7？ sin(1) 呢？
```
rf> 1e fcos  0.7e f< .  1e fsin  0.7e f< .
-1 0  ok
rf> 1e fcos f.  1e fsin f.
0.5403023 0.8414710  ok
```

### 本節指令集

| 指令 | 堆疊效果及指令說明                       | 口語唸法 |
|-----|---------------------------------------|--------|
| `f0<`   | ( -- flag ) ( F: r -- ) &emsp; 當浮點數 r < 0 時 flag 為真 | f-zero-less-than |
| `f0=`   | ( -- flag ) ( F: r -- ) &emsp; 當浮點數 r = 0 時 flag 為真  | f-zero-equals |
| `f<`    | ( -- flag ) ( F: r1 r2 -- ) &emsp; 當浮點數 r1 < r2 時 flag 為真 | f-less-than |
| `f~`    | ( -- flag ) ( F: r1 r2 r3 -- ) &emsp; 依據 r3 提供三種比較方式：如果 r3 為正，(r1 - r2) 的絕對值小於 r3 時為真。如果 r3 為 0，r1 和 r2 的二進位編碼相同時為真。如果 r3 為負，(r1 - r2) 的絕對值小於 r3 乘以 r1 和 r2 的絕對值的和時為真 | f-proximate |

## 位元運算

那麼，二進位的 111<sub>2</sub> 是真還是假呢？答案蠻簡單的，就是有 3 個為真。而 `true` 則代表 64 個為真，或是說完全真。


我們可以用二進制數字不同的位元來代表不同事物的真假。比如，我們可以使用最右邊的位元代表冷氣是否打開，用它左邊的位元代表電風扇是否打開。於是，二進制的 11<sub>2</sub> 代表冷氣和電風扇都開著。10<sub>2</sub> 則代表冷氣開著，但電風扇關著。

```
像 `true` 和 `false` 這類被賦與固定數值的指令，被稱為常數。Forth 定義整數常數的方法如下：
```
<整數> constant <常數名>
```

例子：
variable 狀態  (　定義一個名為「狀態」的整數變數 )
binary  ( 切換到二進制 )
001 constant 冷氣  ( 以右邊數來第一個位元代表冷氣開關 )
010 constant 風扇  ( 以右邊數來第二個位元代表風扇開關 )
100 constant 冰箱 ( 以右邊數來第三 個位元代表風扇開關 )
111 constant 全部
11　狀態　!        ( 目前的狀態是冷氣和風扇都開著、冰箱關著 )
decimal  ( 切換回二進制 )
冷氣 風扇 or　狀態　!        ( 目前的狀態是冷氣和風扇都開著、冰箱關著 )
冷氣  狀態　@  and  .  ( 檢查冷氣是否開著 )
風扇  狀態　@  and  .  ( 檢查風扇是否開著 )
冰箱  狀態　@  and  .  ( 檢查冰箱是否開著 )
冷氣 冰箱 or  狀態　@ 冰箱　and  .  ( 檢查冷氣或是冰箱中是否至少有一個開著 )
狀態　@ 冰箱　冷氣 or and  .  ( 檢查風扇是否開著 )
全部  狀態 @  =  ( 是否全部開著 )
狀態 @  冷氣 xor  全部 and  狀態 !
```
使用位元運算，在處理真假問題時，能一次判斷所有的狀況，這在設計高性能的推理引擎時的重要技巧。

### 本節指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `invert` | ( -- ) &emsp;              | invert |
| `and`    | ( -- ) &emsp;              | and |
| `or`     | ( -- ) &emsp;              | or |
| `xor`    | ( -- ) &emsp;              | xor |

## Bit Logic

## 比較

-------------
## 本章重點整理

* 有號數／無號數
* 十進制
* 二進制
* 十六進制

-------------------------------------
## 本章指令集

| 指令 | 堆疊效果及指令說明                        | 口語唸法 |
|-----|----------------------------------------|--------|
| `invert` | ( -- ) &emsp;              | invert |