# 邏輯運算

## 十進制、二進制、十六進制

人的十根手指頭，決定了人類使用十進制的數字系統。電腦由數量龐大的微型開關構成，只懂開關，或是 0 與 1，使用的是二進制系統。
為了以更簡捷的方式來閱讀二進制系統，人們將二進制中的數字每四位一組，形成了 16 進制。

| 十進制 | 二進制 | 十六進制 |
|------:|------:|--- ----:|
| 0     | 0     | 0       |
| 1     | 1     | 1       |
| 2     | 10    | 2       |
| 3     | 11    | 3       |
| 4     | 100   | 4       |
| 5     | 101   | 5       |
| 6     | 110   | 6       |
| 7     | 111   | 7       |
| 8     | 1000  | 8       |
| 9     | 1009  | 9       |
| 10    | 1010  | A       |
| 11    | 1011  | B       |
| 12    | 1100  | C       |
| 13    | 1101  | D       |
| 14    | 1110  | E       |
| 15    | 1111  | F       |

本文中以下標來表示數字的進制。如 11<sub>10</sub> 代表 10 進制的 11。11<sub>16</sub> 代表 16 進制的 11。11<sub>2</sub>代表 2 進制的 11。

Forth 使用 `decimal` 、`binary` 、 `hex` 這三個指令切換十進制、二進制和十六進制。

指令 `binary` 不是 Forth 2012 標準中的指令。請輸入以下命令以定義這個指令，請注意不要遺漏任何一個空格：

```
rf> : binary  2 base ! ;
 ok
```

例一：以二進制顯示 11<sub>10</sub>。
```
rf> 11  binary .  decimal
1011  ok
```
在上面例子中，因為系統預設為以十進制輸入和顯示數字，11 是十進制的 11<sub>10</sub> 。`binary .` 將輸出入切換到二進制再印出 11<sub>10</sub>，得到 1011<sub>2</sub>。再以 `decimal` 切換為預設的十進制。

例二：以十進制顯示十六進制的 11<sub>16</sub>。
```
rf> hex 11 decimal .
17  ok
```
在上面例子中，因為系統預設為以十進制輸入和顯示數字，先以 `hex` 切換輸出入為十六進制，所以 11 是十六進制的 11<sub>16</sub> 。`decimal .` 則將輸出入切換到十進制再印出 11<sub>16</sub>，得到 17<sub>16</sub>。此時系統已回到預設的十進制。

例三：以二進制印出 -1<sub>10</sub> 和 -2<sub>10</sub>。
```
rf> -1 binary .  decimal
1111111111111111111111111111111111111111111111111111111111111111  ok
rf> -2 binary .  decimal
1111111111111111111111111111111111111111111111111111111111111110  ok

```
在此我們看到負數在電腦中是如何用 0 和 1 表示的。若仔細算算，會發現 -1<sub>10</sub> 的二進制顯示了 64 個 1。 因為這書使用的是 64 位元的作業系統。 如果使用 32 位元的作業系統，我們會看到 32 個 1 。

## 本節指令集

| 指令 | 堆疊效果           | 說明                        | 口語唸法 |
|-----|-------------------|-----------------------------|--------|
| `decimal` | ( -- )|  | decimal |
| `hex` | ( -- )          |  | hex |
| `binary` | ( -- )          |  | binary |

## 真、假、常數、布林運算

同樣，電腦也用 0 和 1 表示真假。Forth 指令 `true` 和 `false` 將真和假放上資料堆疊，讓我們看看它倆的二進制表示法：

例四：以二進制印出 `true` 和 `false` 。
```
rf> true binary . decimal
1111111111111111111111111111111111111111111111111111111111111111  ok
rf> false binary . decimal
0  ok
```
原來 0 不只用來表示十進制的 0<sub>10</sub>，也用來表示假 (false)。而 64 個 1 不只表示十進制的 -1<sub>10</sub>，也表示真 (true) 。 那麼，二進位的 111<sub>2<sub> 是真還是假呢？答案蠻簡單的，就是有 3 個為真。而 `true` 則代表 64 個為真，或是說完全真。

我們可以用二進制數字不同的位元來代表不同事物的真假。比如，我們可以使用最右邊的位元代表冷氣是否打開，用它左邊的位元代表電風扇是否打開。於是，二進制的 11<sub>2</sub> 代表冷氣和電風扇都開著。10<sub>2</sub> 則代表冷氣開著，但電風扇關著。

```


像 `true` 和 `false` 這類被賦與固定數值的指令，被稱為常數。Forth 定義整數常數的方法如下：

```
<整數> constant <常數名>
```

例子：
variable 狀態  (　定義一個名為「狀態」的整數變數 )
binary  ( 切換到二進制 )
001 constant 冷氣  ( 以右邊數來第一個位元代表冷氣開關 )
010 constant 風扇  ( 以右邊數來第二個位元代表風扇開關 )
100 constant 冰箱 ( 以右邊數來第三 個位元代表風扇開關 )
111 constant 全部
11　狀態　!        ( 目前的狀態是冷氣和風扇都開著、冰箱關著 )
decimal  ( 切換回二進制 )
冷氣 風扇 or　狀態　!        ( 目前的狀態是冷氣和風扇都開著、冰箱關著 )
冷氣  狀態　@  and  .  ( 檢查冷氣是否開著 )
風扇  狀態　@  and  .  ( 檢查風扇是否開著 )
冰箱  狀態　@  and  .  ( 檢查冰箱是否開著 )
冷氣 冰箱 or  狀態　@ 冰箱　and  .  ( 檢查冷氣或是冰箱中是否至少有一個開著 )
狀態　@ 冰箱　冷氣 or and  .  ( 檢查風扇是否開著 )
全部  狀態 @  =  ( 是否全部開著 )
狀態 @  冷氣 xor  全部 and  狀態 !
```
使用位元運算，在處理真假問題時，能一次判斷所有的狀況，這在設計高性能的推理引擎時的重要技巧。

### 本節指令集

| 指令 | 堆疊效果           | 說明                        | 口語唸法 |
|-----|-------------------|-----------------------------|--------|
| `true` | ( -- )            |  | true |
| `false` | ( -- )            |  | false |
| `constant` | ( -- )            |  | constant |
| `variable` | ( -- )            |  | variable |
| `@` | ( -- )            |  | fetch |
| `!` | ( -- )            |  | store |
| `and` | ( -- )            |  | and |
| `or` | ( -- )            |  | or |
| `xor` | ( -- )            |  | xor |
| `invert` | ( -- )            |  | u-dot |

## Bit Logic

## 比較

-------------
## 本章重點整理

* 有號數／無號數
* 十進制
* 二進制
* 十六進制

-------------------------------------
## 本章指令集

| 指令 | 堆疊效果           | 說明                        | 口語唸法 |
|-----|-------------------|-----------------------------|--------|
| `decimal` | ( -- )|  | decimal |
| `hex` | ( -- )          |  | hex |
| `binary` | ( -- )          |  | binary |
| `true` | ( -- )            |  | true |
| `false` | ( -- )            |  | false |
| `and` | ( -- )            |  | and |
| `or` | ( -- )            |  | or |
| `xor` | ( -- )            |  | xor |
| `invert` | ( -- )            |  | u-dot |
| `lshift` | ( -- )            |  | u-dot |
| `rshift` | ( -- )            |  | u-dot |
| `u.` | ( u -- )            |  | u-dot |
| `0<` | ( -- )            |  | u-dot |
| `0=` | ( -- )            |  | u-dot |
| `0<>` | ( -- )            |  | u-dot |
| `0>` | ( -- )            |  | u-dot |
| `<` | ( -- )            |  | u-dot |
| `=` | ( -- )            |  | u-dot |
| `>` | ( -- )            |  | u-dot |
| `<>` | ( -- )            |  | u-dot |
| `u<` | ( -- )            |  | u-dot |
| `u>` | ( -- )            |  | u-dot |
| `within` | ( -- )            |  | u-dot |
| `f0<` | ( -- )            |  | u-dot |
| `f0=` | ( -- )            |  | u-dot |
| `f<` | ( -- )            |  | u-dot |
| `f~` | ( -- )            |  | u-dot |