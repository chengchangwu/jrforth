# 邏輯運算

## 十進制、二進制、十六進制

人的十根手指頭，決定了人類使用十進制的數字系統。電腦由數量龐大的微型開關構成，只懂開關，或是 0 與 1，使用的是二進制系統。
為了以更簡捷的方式來閱讀二進制系統，人們將二進制中的數字每四位一組，形成了 16 進制。

| 十進制 | 二進制 | 十六進制 |
|------:|------:|--------:|
| 0     | 0     | 0       |
| 1     | 1     | 1       |
| 2     | 10    | 2       |
| 3     | 11    | 3       |
| 4     | 100   | 4       |
| 5     | 101   | 5       |
| 6     | 110   | 6       |
| 7     | 111   | 7       |
| 8     | 1000  | 8       |
| 9     | 1009  | 9       |
| 10    | 1010  | A       |
| 11    | 1011  | B       |
| 12    | 1100  | C       |
| 13    | 1101  | D       |
| 14    | 1110  | E       |
| 15    | 1111  | F       |

本文中以下標來表示數字的進制。如 11<sub>10</sub> 代表 10 進制的 11。11<sub>16</sub> 代表 16 進制的 11。11<sub>2</sub>代表 2 進制的 11。

Forth 使用 `decimal` 、`binary` 、 `hex` 這三個指令切換十進制、二進制和十六進制。

指令 `binary` 不是 Forth 2012 標準中的指令。但 rtForth 內建了這個指令。如果你使用的 Forth 沒有 `binary`，可以輸入以下命令定義這個指令，注意不要遺漏任何一個空格：

```
: binary  2 base ! ;
```

例一：以二進制顯示 11<sub>10</sub>。
```
rf> 11  binary .  decimal
1011  ok
```
在上面例子中，因為系統預設為以十進制輸入和顯示數字，11 是十進制的 11<sub>10</sub> 。`binary .` 將輸出入切換到二進制再印出 11<sub>10</sub>，得到 1011<sub>2</sub>。再以 `decimal` 切換為預設的十進制。

例二：以十進制顯示十六進制的 11<sub>16</sub>。
```
rf> hex 11 decimal .
17  ok
```
在上面例子中，因為系統預設為以十進制輸入和顯示數字，先以 `hex` 切換輸出入為十六進制，所以 11 是十六進制的 11<sub>16</sub> 。`decimal .` 則將輸出入切換到十進制再印出 11<sub>16</sub>，得到 17<sub>16</sub>。此時系統已回到預設的十進制。

例三：以二進制印出 -1<sub>10</sub> 和 -2<sub>10</sub>。
```
rf> -1 binary .  decimal
1111111111111111111111111111111111111111111111111111111111111111  ok
rf> -2 binary .  decimal
1111111111111111111111111111111111111111111111111111111111111110  ok

```
在此我們看到負數在電腦中是如何用 0 和 1 表示的。若仔細算算，會發現 -1<sub>10</sub> 的二進制顯示了 64 個 1。 因為這書使用的是 64 位元的作業系統。 如果使用 32 位元的作業系統，我們會看到 32 個 1 。

## 本節指令集

| 指令 | 堆疊效果           | 說明                        | 口語唸法 |
|-----|-------------------|-----------------------------|--------|
| `decimal` | ( -- )|  | decimal |
| `hex` | ( -- )          |  | hex |
| `binary` | ( -- )          |  | binary |

## 真和假

電腦也用 0 和 1 表示真假。Forth 指令 `true` 和 `false` 將真和假放上資料堆疊，讓我們看看它倆的二進制表示法：

例四：以二進制印出 `true` 和 `false` 。
```
rf> true binary . decimal
1111111111111111111111111111111111111111111111111111111111111111  ok
rf> false binary . decimal
0  ok
```
所以 0 不只是十進制的 0<sub>10</sub>，也用來表示假 (false)。而 64 個 1 不只是十進制的 -1<sub>10</sub>，也表示真 (true) 。

這和許多語言不同，C 語言的 true 是 1 。Forth 以 -1 為真，在進行位元運算時有其好處。請見位元運算一節。

Forth 有許多指令的結果是真或假。其中大宗就是比概指令。像 `0=` ，用來比較堆疊上的整數是不是零。像 `=` 用來比較兩個整數是否相等。像 `f~`，用來比較浮點數是否近似。請參考本節的指令集並練習以下例子。

例五：比較 -1 、 0 、 1 和 0 的關係。
```
rf> -1 0< .  0 0= .  1 0> .
-1 -1 -1  ok
rf> 0 0<> .
0  ok
```
所以 -1 < 0， 0 = 0， 1 > 0 且 0 不會不等於 0。

例六：比較 2 6 8 和 6 之間的關係。
```
rf> 2 6 < .  6 6 = .  6 6 <> .  8 6 > .
-1 -1 0 -1  ok
```
所以 2 < 6， 6 = 6， 6 不會不等於 6， 8 大於 6。

例七：cos(1) 是否小於 0.0？ sin(0) 是否等於 0.0？
```
rf> 1e fcos f0< .
0  ok
rf> 0e fsin f0= .
-1  ok
```
所以 cos(1) 不小於 0.0，且 sin(0) = 0.0。

例七：cos(1) 是否小於 0.7？ sin(1) 呢？
```
rf> 1e fcos  0.7e f< .  1e fsin  0.7e f< .
-1 0  ok
rf> 1e fcos f.  1e fsin f.
0.5403023 0.8414710  ok
```

### 本節指令集

| 指令 | 堆疊效果           | 說明                        | 口語唸法 |
|-----|-------------------|-----------------------------|--------|
| `true` | ( -- true )    | 回傳一所有位元都為 1 的整數 | true |
| `false` | ( -- false )  | 回傳一所有位元都為 0 的整數 | false |
| `0<` | ( n -- flag )    | 當 n < 0 時 flag 為真 | zero-less |
| `0=` | ( n -- flag )    | 當 n = 0 時 flag 為真 | zero-equals |
| `0<>` | ( n -- flag )   | 當 n 為不 0 時 flag 為真 | zero-not-equals |
| `0>` | ( n -- flag )    | 當 n > 0 時 flag 為真 | 0-greater |
| `<` | ( n1 n2 -- flag )            |  | less-than |
| `=` | ( n1 n2 -- flag )            |  | equals |
| `>` | ( n1 n2 -- flag )            |  | greater-than |
| `<>` | ( n1 n2 -- flag )            |  | not-equals |
| `f0<` | ( -- flag ) ( F: r -- )            |  | f-zero-less-than |
| `f0=` | ( -- flag ) ( F: r -- )           |  | f-zero-equals |
| `f<` | ( -- flag ) ( F: r1 r2 -- )           |  | f-less-than |
| `f~` | ( -- flag ) ( F: r1 r2 r3 -- ) | 提供三種比較方式：如果 r3 為正，(r1 - r2) 的絕對值小於 r3 時為真。如果 r3 為 0，r1 和 r2 的二進位編碼相同時為真。如果 r3 為負，(r1 - r2) 的絕對值小於 r3 乘以 (r1 + r2) 的絕對值時為真。| f-proximate |

## 位元運算

那麼，二進位的 111<sub>2<sub> 是真還是假呢？答案蠻簡單的，就是有 3 個為真。而 `true` 則代表 64 個為真，或是說完全真。


我們可以用二進制數字不同的位元來代表不同事物的真假。比如，我們可以使用最右邊的位元代表冷氣是否打開，用它左邊的位元代表電風扇是否打開。於是，二進制的 11<sub>2</sub> 代表冷氣和電風扇都開著。10<sub>2</sub> 則代表冷氣開著，但電風扇關著。

```


像 `true` 和 `false` 這類被賦與固定數值的指令，被稱為常數。Forth 定義整數常數的方法如下：

```
<整數> constant <常數名>
```

例子：
variable 狀態  (　定義一個名為「狀態」的整數變數 )
binary  ( 切換到二進制 )
001 constant 冷氣  ( 以右邊數來第一個位元代表冷氣開關 )
010 constant 風扇  ( 以右邊數來第二個位元代表風扇開關 )
100 constant 冰箱 ( 以右邊數來第三 個位元代表風扇開關 )
111 constant 全部
11　狀態　!        ( 目前的狀態是冷氣和風扇都開著、冰箱關著 )
decimal  ( 切換回二進制 )
冷氣 風扇 or　狀態　!        ( 目前的狀態是冷氣和風扇都開著、冰箱關著 )
冷氣  狀態　@  and  .  ( 檢查冷氣是否開著 )
風扇  狀態　@  and  .  ( 檢查風扇是否開著 )
冰箱  狀態　@  and  .  ( 檢查冰箱是否開著 )
冷氣 冰箱 or  狀態　@ 冰箱　and  .  ( 檢查冷氣或是冰箱中是否至少有一個開著 )
狀態　@ 冰箱　冷氣 or and  .  ( 檢查風扇是否開著 )
全部  狀態 @  =  ( 是否全部開著 )
狀態 @  冷氣 xor  全部 and  狀態 !
```
使用位元運算，在處理真假問題時，能一次判斷所有的狀況，這在設計高性能的推理引擎時的重要技巧。

### 本節指令集

| 指令 | 堆疊效果           | 說明                        | 口語唸法 |
|-----|-------------------|-----------------------------|--------|
| `invert` | ( -- )            |  | invert |
| `and` | ( -- )            |  | and |
| `or` | ( -- )            |  | or |
| `xor` | ( -- )            |  | xor |

## Bit Logic

## 比較

-------------
## 本章重點整理

* 有號數／無號數
* 十進制
* 二進制
* 十六進制

-------------------------------------
## 本章指令集

| 指令 | 堆疊效果           | 說明                        | 口語唸法 |
|-----|-------------------|-----------------------------|--------|
| `decimal` | ( -- )|  | decimal |
| `hex` | ( -- )          |  | hex |
| `binary` | ( -- )          |  | binary |
| `true` | ( -- )            |  | true |
| `false` | ( -- )            |  | false |
| `and` | ( -- )            |  | and |
| `or` | ( -- )            |  | or |
| `xor` | ( -- )            |  | xor |
| `invert` | ( -- )            |  | u-dot |